using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;

namespace Tao
{  
    public class MethodDefSignatureReader
    {
        public Read([NotNull] stream : Stream) : MethodDefSignature
            requires stream.CanRead
            requires stream.Position < stream.Length
            ensures value != null
        {
            def signature = MethodDefSignature();
            def reader = BinaryReader(stream);
            mutable nextByte = reader.ReadByte();                      
            def hasFlag(currentByte : byte, convention : CallingConvention) : bool
            {
                (currentByte & (convention :> byte)) != 0;
            }
            
            when(hasFlag(nextByte, CallingConvention.ExplicitThis) && !hasFlag(nextByte, CallingConvention.HasThis))
            {
                throw BadImageFormatException("You can't declare a method as ExplicitThis without first setting the HasThis flag");
            }

            // Read the HasThis -> ExplicitThis [Optional] bytes
            when(hasFlag(nextByte, CallingConvention.HasThis))
            {
                signature.HasThis = true;
                when(hasFlag(nextByte, CallingConvention.ExplicitThis))
                {
                    signature.HasExplicitThis = true;                    
                }                
            }
                        
            def integerReader = CompressedIntegerReader();
            if(hasFlag(nextByte, CallingConvention.VarArg))
            {
                signature.UsesVariableArguments = true;
            }
            else if(hasFlag(nextByte, CallingConvention.Generic))
            {
                // Read the number of generic parameters as a compressed unsigned int                
                def genericParamCount = integerReader.ReadInteger(stream);

                signature.IsGeneric = true;
                signature.GenericParameterCount = genericParamCount;
            }
            else
            {
                signature.UsesDefaultCallingConvention = true;    
            }

            // Read the parameter count
            def parameterCount = integerReader.ReadInteger(stream);
            signature.ParameterCount = parameterCount;

            def retTypeReader = RetTypeReader();
            signature.ReturnType = retTypeReader.Read(stream);

            // TODO: If the Signature is VarArgs and is a MethodRefSig, watch out for the Sentinel byte
            def paramReader = ParamReader();
            for(mutable i : uint = 0; i < parameterCount; i++)
            {
                def currentParam = paramReader.Read(stream);
                signature.Parameters.Add(currentParam);
            }
            
            signature;
        }
    }
}
