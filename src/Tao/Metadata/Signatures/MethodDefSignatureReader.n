using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;

namespace Tao
{  
    public class MethodDefSignatureReader
    {
        public Read([NotNull] stream : Stream) : MethodDefSignature
            requires stream.CanRead
            requires stream.Position < stream.Length
            ensures value != null
        {
            def signature = MethodDefSignature();
            def reader = BinaryReader(stream);
            mutable nextByte = reader.ReadByte();                      
            def hasFlag(currentByte : byte, convention : CallingConvention) : bool
            {
                (currentByte & (convention :> byte)) != 0;
            }

            when(hasFlag(nextByte, CallingConvention.ExplicitThis) && !hasFlag(nextByte, CallingConvention.HasThis))
            {
                throw BadImageFormatException("You can't declare a method as ExplicitThis without first setting the HasThis flag");
            }

            // Read the HasThis -> ExplicitThis [Optional] bytes
            when(hasFlag(nextByte, CallingConvention.HasThis))
            {
                signature.HasThis = true;
                when(hasFlag(nextByte, CallingConvention.ExplicitThis))
                {
                    signature.HasExplicitThis = true;                    
                }                
            }

            def integerReader = CompressedIntegerReader();
            if(hasFlag(nextByte, CallingConvention.VarArg))
            {
                signature.UsesVariableArguments = true;
            }
            
            else if(hasFlag(nextByte, CallingConvention.Generic))
            {
                // Read the number of generic parameters as a compressed unsigned int                
                def genericParamCount = integerReader.ReadInteger(stream);

                signature.IsGeneric = true;
                signature.GenericParameterCount = genericParamCount;
            }
            else
            {
                signature.UsesDefaultCallingConvention = true;    
            }

            // Read the parameter count
            def parameterCount = integerReader.ReadInteger(stream);
            signature.ParameterCount = parameterCount;

            def retTypeReader = RetTypeReader();
            signature.ReturnType = retTypeReader.Read(stream);            

            ReadParameters(parameterCount, stream, signature);

            signature;
        }
        private ReadParameters(parameterCount : uint, [NotNull] stream : Stream, signature : MethodDefSignature) : void
            requires parameterCount == 0 || (parameterCount > 0 && stream.Position < stream.Length) otherwise throw InvalidOperationException("Unable to read past the end of the stream")
        {
            // TODO: If the Signature is VarArgs and is a MethodRefSig, watch out for the Sentinel byte
            for(mutable i : uint = 0; i < parameterCount; i++)
            {                
                ReadParameter(i, signature, stream);
            }
        }
        protected virtual ReadParameter(index : uint, signature: MethodDefSignature, stream : Stream) : void
        {
            def paramReader = ParamReader();

            def currentParam = paramReader.Read(stream);
            signature.Parameters.Add(currentParam);
        }
    }
}
