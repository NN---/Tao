using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Tao;
using Tao.Interfaces;
using Tests.Macros;

using System;
using System.IO;
using System.Reflection;
using System.Collections.Generic;
using System.Linq;

namespace Tests
{  
  public class MetadataStreamHeaderTests
  {    
    public ShouldReadName() : void
    {
      TestRead("Name", "#~");
    }
    public ShouldReadSize() : void
    {
      TestRead("Size", 0x4034 :> uint);
    }
    public ShouldReadOffset() : void
    {
      TestRead("Offset", 0x6C :> uint);
    }
    public ShouldWriteName() : void
    {
      TestWrite("Name", "#Foo");
    }
    public ShouldWriteSize() : void
    {
      TestWrite("Size", 0xFEED : uint);
    }
    public ShouldWriteOffset() : void
    {
      TestWrite("Offset", 0xFEED : uint);
    }        
    public ShouldThrowBadImageFormatExceptionIfHeaderNameIsEmptyOnWrite() : void
        expects BadImageFormatException
    {
        def header = StreamHeader();
        def stream = MemoryStream();
        def writer = StreamHeaderWriter();
        def items = array[header];
        writer.Write(items, stream);
    }
    
    private TestWrite[TValue](propertyName : string, expectedValue : TValue) : void
    {      
      def createHeader() : IEnumerable[IStreamHeader]
      {
        def targetProperty = typeof(IStreamHeader).GetProperty(propertyName, BindingFlags.Public | BindingFlags.Instance);
        def results = List.[IStreamHeader]();
        def header = StreamHeader();
        header.Name = "#SampleStreamName";
        targetProperty.SetValue(header, expectedValue, null);
            
        results.Add(header);
        results;
      };
        
      def readValue(reader : BinaryReader) : TValue
      {
        def targetProperty = typeof(IStreamHeader).GetProperty(propertyName, BindingFlags.Public | BindingFlags.Instance);
        def stream = reader.BaseStream;
        stream.Seek(0, SeekOrigin.Begin);
        def streamReader = StreamHeaderReader();
        def header = streamReader.Read(1, stream).First();
        def result = targetProperty.GetValue(header, null) :> TValue;
        
        result;
      }
        
      Tester.TestElementWrite.[TValue, IStreamHeader, StreamHeaderWriter](propertyName, expectedValue, createHeader, readValue);
    }
    private TestRead[TValue](propertyName : string, expectedValue : TValue) : void
    {
      Tester.TestElementRead.[ushort, IStreamHeader, StreamHeaderReader, TValue](0, 1, propertyName, expectedValue, GetSampleHeader);        
    }
    
    private GetSampleHeader() : array[byte]
    {
     array[
        // Offset = 0x0000006C
	    0x6C : byte, 0x00, 0x00, 0x00, 
	    // Size = 0x00004034
	    0x34, 0x40, 0x00, 0x00, 
	    // Name = "#~\0\0"
	    0x23, 0x7E, 0x00, 0x00
        ];
    }
  }
}
