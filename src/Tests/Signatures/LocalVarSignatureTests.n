using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using Tests.Macros;
using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;

using Tao;
using Tao.Metadata;
using Tao.Metadata.Signatures;
using Tao.Metadata.Tables;
using Tao.Metadata.Tables.Rows;
using SampleCustomAttributeUsage;

namespace Tests
{
    public class LocalVarSignatureTests : FileBasedTableTest
    {
        public ShouldBeAbleToGetStandAloneSigBlob() : void
        {
            def root = base.GetMetadataRoot();            
            def tableStream = root.Heaps["#~"];

            def heap = TablesHeap();
            heap.ReadFrom(tableStream);

            def blobStream = root.Heaps["#Blob"];
            
            def standAloneSigRow = heap.GetRow.[StandAloneSigRow](1);
            standAloneSigRow.ShouldBeNotNull("The assembly should have at least one StandAloneSig row");
            
            def signatureBlob = standAloneSigRow.Signature.ToBlob(blobStream);
            (signatureBlob.Length > 0).ShouldBeTrue("Invalid standalone signature blob");            
        }
        public stub ShouldFailIfLocalSigByteNotEncountered() : void
        {
        }
        public ShouldReadCount() : void
        {
            def shouldHaveCorrectCount(signature : LocalVarSignature, expectedCount : uint)
            {
                (signature.Locals.Count == 1).ShouldBeTrue("Wrong LocalVarSig count");
            }
            
            TestRead(shouldHaveCorrectCount(_, 1 : uint));
        }
        public stub ShouldReadCustomMods() : void
        {
        }
        public stub ShouldReadConstraint() : void
        {
        }
        public ShouldReadByRef() : void
        {
            def shouldBeByRef(signature : LocalVarSignature) : void
            {
                def local = signature.Locals[0];
                local.IsByRef.ShouldBeTrue("The signature should be ByRef");
                local.HasConstraint.ShouldBeFalse("This LocalVarSignature should not have any constraints");
            }
            
            TestRead(shouldBeByRef);
        }
        
        public ShouldReadLocalType() : void
        {
            def shouldHaveCorrectType(local : LocalVariable) : void
            {
                local.VariableType.ElementType.ShouldBeEqualTo(ElementType.I4, "Wrong local variable element type");
            }
            TestRead(Transform(shouldHaveCorrectType, 0));
        }
        
        public stub ShouldReadTypedByRef() : void
        {
        }
        public stub ShouldWriteCount() : void
        {
        }
        public stub ShouldWriteCustomMods() : void
        {
        }
        public stub ShouldWriteConstraint() : void
        {
        }
        public stub ShouldWriteByRef() : void
        {
        }
        public stub ShouldWriteLocalType() : void
        {
        }
        public stub ShouldWriteTypedByRef() : void
        {
        }
        
        private Transform(test : LocalVariable -> void, index : int) : LocalVarSignature -> void
        {            
            def doTest(signature : LocalVarSignature) : void
            {
                def local = signature.Locals[index];
                test(local);
            }
            doTest;
        }
        
        private TestRead(doTest : LocalVarSignature -> void) : void
        {
            def root = base.GetMetadataRoot();            
            def tableStream = root.Heaps["#~"];

            def heap = TablesHeap();
            heap.ReadFrom(tableStream);

            def stringHeap = root.Heaps["#Strings"];           
            def blobStream = root.Heaps["#Blob"];
            
            def standAloneSigRow = heap.GetRow.[StandAloneSigRow](1);
            standAloneSigRow.ShouldBeNotNull("The assembly should have at least one StandAloneSig row");
            
            def signatureBlob = standAloneSigRow.Signature.ToBlob(blobStream);
            def reader = LocalVarSignatureReader();
            
            def result = reader.ReadFrom(MemoryStream(signatureBlob));
            doTest(result);
        }
        protected override TargetAssemblyFileName : string 
        { 
            get
            {
                "LocalVarSig1.dll";
            }
        }
    }
}
