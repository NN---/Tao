using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using Tao;
using Tao.Interfaces;
using Tao.Metadata;
using Tao.Metadata.Tables;
using Tao.Metadata.Tables.Rows;

using Tests.Macros;
using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;

namespace Tests
{
    public class MethodBodyTests
    {
        public ShouldBeAbleToDetermineThinHeader() : void
        {
            def bytes = GetData();
            def reader = MethodBodyReader();

            def body = reader.Read(MemoryStream(bytes));
            body.ShouldBeOfType.[TinyMethodBody]();            
        }
        public ShouldBeAbleToDetermineMethodBodySize() : void
        {
            def bytes = GetData();
            def reader = MethodBodyReader();

            def body = reader.Read(MemoryStream(bytes));
            body.ShouldBeOfType.[TinyMethodBody]();            

            body.CodeSize.ShouldBeEqualTo(0x18, "Wrong method body size");
        }

        public ShouldBeAbleToReadFatHeader() : void
        {
            def assemblyFile = @"..\..\SampleBinaries\SampleAppWithFatMethodBody.exe";
            
            def testFatBody(fatBody : FatMethodBody) : void
            {
                fatBody.Flags.ShouldBeEqualTo(0x3013, "Invalid Flags");
                fatBody.MaxStack.ShouldBeEqualTo(2, "Invalid MaxStack value");
                fatBody.LocalVarSigToken.ShouldBeEqualTo(0x11000001, "Invalid LocalVarSigToken");
                fatBody.InitLocals.ShouldBeTrue("InitLocals should be true");
                fatBody.CodeSize.ShouldBeEqualTo(11, "Invalid code size");

                // Match the instructions in the method body
                def expectedBytes = array[0x00 : byte, 0x02, 0x03, 0x58, 0x0A, 0x06, 0x0B, 0x2B, 0x00, 0x07, 0x2A];
                fatBody.Bytes.ShouldMatch(expectedBytes);
            }

            TestFatMethodBody(assemblyFile, testFatBody);
        }
        public ShouldBeAbleToExtractMethodRowsAndMethodRVAs() : void
        {
            def targetAssembly = @"..\..\SampleBinaries\SampleAppWithFatMethodBody.exe";
            def image = Image.ReadFrom(targetAssembly);
            def root = image.GetMetadataRoot();

            def tableStream = root.Heaps["#~"];
            def tableHeap = TablesHeap();
            tableHeap.ReadFrom(tableStream);

            def rows = tableHeap.GetRows.[MethodDefRow]().ToArray();
            rows.Length.ShouldBeEqualTo(4, "Invalid row count");

            rows[0].Rva.ShouldBeEqualTo(0x00002050, "Invalid Rva");
            rows[3].Rva.ShouldBeEqualTo(0x0000207C, "Invalid Rva");
        }
        public stub ShouldReadExceptionHandlerBlocks() : void
        {

        }
        public ShouldReadSingleExceptionHandlerBlock() : void
        {
            def targetAssembly = @"..\..\SampleBinaries\SampleAppWithExceptionHandlersInMethod.exe";
            
            def testFatBody(fatBody : FatMethodBody) : void
            {
                def handlerBlocks = fatBody.ExceptionHandlerBlocks;
                handlerBlocks.Count().ShouldBeEqualTo(1, "Wrong number of expected handler blocks");
                
                def block = handlerBlocks.First();
                block.GetType().ShouldBeEqualTo(typeof(ThinExceptionBlockHeader), "Wrong header type");
                
                def thinBlock = block :> ThinExceptionBlockHeader;
                thinBlock.Clauses.Count().ShouldBeEqualTo(1, "Wrong number of expected clauses");
                
                thinBlock.DataSize.ShouldBeEqualTo(16, "Wrong Data Size");
                def clause = thinBlock.Clauses.First();                
                clause.TryOffset.ShouldBeEqualTo(1, "Wrong Try Offset");
                clause.TryLength.ShouldBeEqualTo(0x24, "Wrong Try Length");
                clause.HandlerOffset.ShouldBeEqualTo(0x25, "Wrong Handler Offset");
                clause.HandlerLength.ShouldBeEqualTo(16, "Wrong Handler Length");
            }
            TestFatMethodBody(targetAssembly, "Main", testFatBody);
        }
        
        public stub ShouldWriteExceptionHandlerBlocks() : void
        {
        }
        public stub ShouldWriteMultipleExceptionHandlerBlocks() : void
        {
        }
        private TestFatMethodBody(assemblyFile : string, methodName : string, testFatBody : FatMethodBody -> void) : void
        {
            def pickMatchingMethod(stringHeap : Stream, rows : array[MethodDefRow]) : MethodDefRow
            {
                rows.First(r => r.Name.ToString(stringHeap) == methodName);
            }
            TestFatMethodBody(assemblyFile, pickMatchingMethod, testFatBody);
        }
        private TestFatMethodBody(assemblyFile : string, chooseMethodRow : Stream * array[MethodDefRow] -> MethodDefRow, testFatBody : FatMethodBody -> void) : void
        {
            def imageStream = File.ReadAllBytes(assemblyFile);

            def image = Image.ReadFrom(imageStream.ToStream());
            def root = image.GetMetadataRoot();

            def tableStream = root.Heaps["#~"];
            def tableHeap = TablesHeap();
            tableHeap.ReadFrom(tableStream);

            // Find the target method
            def rows = tableHeap.GetRows.[MethodDefRow]().ToArray();            
            def fatMethodRow = chooseMethodRow(root.GetStringHeap(), rows);

            def rva = fatMethodRow.Rva;
            def methodStream = image.GetDataAt(rva);
            def reader = MethodBodyReader();

            def body = reader.Read(methodStream);
            body.ShouldBeOfType.[FatMethodBody]();            

            def fatBody = body.As.[FatMethodBody]();
            testFatBody(fatBody);
        }
        private TestFatMethodBody(assemblyFile : string, testFatBody : FatMethodBody -> void) : void
        {
            def pickFirstRow(stringHeap : Stream, rows : array[MethodDefRow]) : MethodDefRow
            {
                rows[1];
            }

            TestFatMethodBody(assemblyFile, pickFirstRow, testFatBody);
        }
        private GetData() : array[byte]
        {
            def methodData = array[0x62 : byte, 0x00, 0x72, 0x01, 0x00, 0x00, 0x70, 0x28, 0x11, 0x00, 0x00, 0x0A, 0x00, 0x72, 0x1D, 0x00,
                0x00, 0x70, 0x28, 0x11, 0x00, 0x00, 0x0A, 0x00, 0x2A
            ];

            methodData;
        }
    }
}
